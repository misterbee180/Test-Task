When a task instance is generated it's associated w/ the original task and the original task is associated w/ it's time element. The time element in this case exists as a means to know when to generate the task instance entirely. Once the instance is created there's no means for knowning when an instance is actually supposed to be used. This issue is specific to repeating tasks. For non repeating tasks the time detail for the task is the correct time detail for the instance.

Options
1. Each repeating task instance is associated w/ its own time instance.
2. Each repeating task instance is associated w/ a to and from date (the date being the day of the week or month that the task was generated for)

Advanages for 1
1) all time details available and shouldn't be a problem establishing proper queue
2) will have to parse time details all over again

New option:
3. Have a generic time instance w/ only from and to per repeating instance. This will be generated off of the time instance. When editing a task later we can simply edit the tasks instances details

Disadvantage of 1 & 3
1) We're creating a seperation of a task and it's task instance. The user will now need to be aware that when editing a task instance (of a repeating task) that it'll only update the specific instance. This issue is possible less detrimental if we go w/ the generic time record because it won't be repeating and can be made to not allow for repetition selection. This way it'll be apparent that the changes being made to the task instance are specific to the instance. If they wanted to change the task they can go to the task viewer or we can later add a jump to associated task instance 

Implementation of 3
When a task instance is generated it will determine if it's repeating or not. If not it'll assign the time id associated w/ the task to the task instance. If it is repeating then it'll create a new time instance and establish it's dates as non repeating elements. 

We need to add a time ID field to task instance.

Where do we add task instances?
Long term after a task is completed so that we have a record of that tasks completion. This is sketchy but necessary because long term tasks are storred as tasks and don't have any means of signifying completion outside of generating a completed task instance. They also create a task instance when a long term item has a date associated w/ it.

Event tasks create instances when activated. Again, event tasks are created as events and the only way to establish that an event is active is when there's a non completed event task instance. Also to identify which tasks were uncompleted that logic is also used.

The main purpose of having these things create task instances is so that they'd display on the task display screen. At least that's what the main purpose should be. To determine the type of task instance we're working with we look at the associated task and that has the id's of the task type it is.

What date do we need to pass to the time detail associated w/ the task instance. Currently I have it passing out from and to but really, the from date is really all that matters right? The from date will determine if it should fall into T, U, or S queues and the time detail will determine if it falls into T or P. But what if all that's provided is a to date? Well if that's the case (which I don't think you can do now) then the task will never wind up in the U queue. So we would generate an instance and say that the date is today and the time is from until to time. This will be regerated w/ a new from date every day until the to date is met. At which point it will continue to regenerate instances w/ a from date as the to date and will thus always occur in the S section.

With all this said and done I think I'm realizing that a task instance should really incapsulate it's own time details. It does not need to make use of the time table. A task instance should really only need a from date, to date, associated task id

So... w/ all of this said the plan from here on is:
- Update task instance table to include columns:
	- From Date
	- To Date
	- From Time Set
	- To Time Set
	...
	
How will altering a repeating task work w/ new task instances being generated daily? The idea is that a task instance can be regenerated daily but now that we're planning on seperating the editing of a task instance from the editing of a task it becomes a lot more complex. Effectively if you edit a task instance it's in 2 parts. One you want to edit a task's name or description 2) you want to edit a task instances time details 3) you want to edit the tasks time details. So effectively we can't be regenerating task instances daily & allowing the editing of tasks seperately from task instances. Best case scenario you'll wind up with 2 task instances (originating from the same task) but one having been edited from the original task and the other matching the original task. Effectively an editing of a task instance should affect the task but that can't be the case in this new system.

What I want to happen is when I edit a task instance that it knows not to regenerate a new task instance UNTIL the current task instance is completed. But what if I were to edit a task instance and never complete it. Then the entire system design is halted becaus the task is never completed. If a task is a repeating task and the original task instance is altered I'd want it to generate a new instance of task instance when the next repetition opportunity occurred. I don't know if i'd want it to remove the altered version of the task yet. In theory the altered version of the task shouldn't be necessary once a new version of the task is regenerated but what if there were some details specific to that task instance... Currently this is not possible but it might be desired that task instances have base details from their task but can be updated to have differing details later. If this was the case I'd like to keep the altered version of task instance and just generate a new version of the task instance at that time. So what about setting an evaluation date on a task. When the current date is after the evaluation date then we regenerate the task instance. Otherwise we don't regenerate it. This would be good because instead of having a really complex logic for determining what tasks to select for evaluation we simply select all tasks w/ an evaluation date in the past. But what does an evaluation date mean? For a task w/o repetition, I'd imagine there'd be no evaluation date or maybe highdate. This would also be the case for event tasks and long term tasks. For repeting tasks the evaluation date is more critical. If it's repeating on a day schedule the next evaluation would be the next day. If it's repeating on a weekly schedule the next evaluation would be the next day of the week it's associated w/. For month it'd be the next day of the month it's associated w/ and for year it's the next day of year it's associated w/. This brings up 3 questions: 1) What happens if the app doesn't evaluate on a specific evaluation day? 2) If we provide the evaluation day then do we need to do any additional logic on the evaluation day or can we just create the task instance? 3) How will evaluation dates work w/ upcoming task instances?

#3 seems most important to answer first. The evaluation date was originally the day the task instance should be generated BUT if you're expecting task instances to generate a few days out then would the evaluation date change to reflect that? If an evaluation date 

...

Does an event need to be associated w/ a time?
Initially no. An event has tasks associated to it but those tasks are never created for a specific date or time or repetition. An event is simply activated and when activated Task instances are created which allow for view on the main display tool. In this case there is no need for a from and to date as all instances of this type are simply displayed in the event queue. If we were to use task instances as a means for displaying event tasks during activation than we'd need a to identify those instances as associated to an event. This is currently done by linking instances to their task and then to their event. So the answer is no.

So this means that a time detail is not always associated w/ a task and thus a time element should hold a task id and not the other way around. When will a task not have a time detail:
- When no time details are specified during task creation
- When event tasks are created
- When long term tasks are created w/o time details.
Time details will be created when:
- time details are provided during normal task creation
- time details are provided during long term task creation.

In theory a task is either associated w/ no time some sort of time detail. Currently I have it set up that a a time detail contains from and to and extra repetition details exist that make use of thsoe details. Really though you could say that no repetition is a repetition type "None". Then you have the various repetition types (Day, Week, Month, Year). It would almost make sense to just store from and to dates on the actual date type table. The one reservation i have is with the occurrences as this is effectively a detail only specific to repetitions and "None" would never have an occurrence detail. The way it is now, if a time detail exists then it'll have a upcoming and priority date. However if I were to make this change then a task would always be associated to some repetition type, and a none type would have to have an indicator for no time. What I like about this design is that it gets away with repetition types all using the same from and to dates and trying to make that logic work. It does but it's ugly. What I don't like is that a task will always be associated to a repetition type and that in one repetition type (None) I need to handle generation two different ways. We could have repetition type be empty in the case where there's no time details, populated w/ n when there's time but no repetition, and populated w/ other chars when there is repetition. Then when there's no repetition I can know to create a task instance, when there's a repetition i know to use the dates to generate task instance.

Wow I lost a lot of notes that's too bad :( Computer restarts are killer :(

Anyway, now that I have the idea of thru dates I'm wondering about the logic for when you add a task to a session already in progress (for instance, a weekend session, during that weekeend you add an instance). Especially if it's simply a one off. On one hand, the session is still active and so there's teh possibility that you'd want to add it there. On the other hand if you wanted to do the task today you should just add the task to the list today. But what if it's saturday and you want to do it sometime this weekend. So you'd want it this weekend. The logic could be somewhat complex. Add it this weekend and if not completed... no this wouldn't work because if not completed the task instance would never go away. So at this point the only way I can see to do it is to have a checkbox that occurs in this situation that allows generation during current instance. If not checked it'll just assign it to the next logical time instance.

 

Establishing dates for tasks will be done by:
- Establishing create date
- Using occurs in combination w/ the repetition type to determine the repetition instance that occurs directly after or includes the current day.
For day we'd say the task was created on 3/5 and it occurs every day so the date would be set to 4/1 (today)
For week that occurs every 2 weeks and created on 3/5,
- First, we'd determine what the sunday of that week was (beginning of week) 
- Then from that date we'd add multiples of 7 days * 2 (occures) until the current day is either before the new date OR the current day is between the new date and the end of the week of that new date (new date + 7)
- Then establishing what day of the week the current day is we'd find the applicable current or day of the week. 
- If one exists then return that, otherwise call itself w/ the next possible week group.

I think i'm going to change over to only one evaluation dates assocaited w/ a time element. There's no need for 2. However, now I need to consider how that date is actually established w/ respects to upcoming dates being part of the mix. For instance, if the day of the week that a task is set for is wednesdat and there's a 2 day upcoming notice then really the day of the week that I want to find is Monday. Even better, if the day was sunday then the actual date I'm looking for is friday the week before. To accomplish this, I need to establish what that date would be. I would find the week..

I'm struggling w/ establishing the date evaluation logic. There are a few scenarios that are overlapping so I'm going to write them out.

First is the standard case. I create a task that has a repetition date every week for a week day of sunday which happens to be today. In this case I want a task generated for this week. If I were to have my week upcoming settings tuned to 7 days, i'd also want a task instance created for upcoming tasks. I do not want a standard task created for the past. So to make this happen I would get the current week, and evaluate through the days of the week. The first instance should be sunday as that is the beginning of the week. I'd confirm the current day is part of the repetition time and establish the priority date. I would then establish the upcoming date which would be the sunday date - 7 days (in this example). I'd apply both dates to the time object and pass out the generate date from the fucntion. This would lead to the creation of a task instance w/ the priority date as the from date. Then because a task instance was created the date evaluation would occur again. This time I would have a prior priority date. I would use the prior priority date as a beginning cutoff for any future task creation. Thus when it establishes the week to iterate through it will ignore sunday as that day matches the prior priorty date. It would then continue through the week. Though the days would be after the current date they would not match the repetition conditition of sunday and thus would not establish a new date. Once at the end of the week the function would call itself passing the prior priority date and and the new week to evaluate. To do this it would determine what the occur value is and from the beginning of the week jump 7(days) * Occur to move to the beginning of the next week. Once in the new function it would iterate through the newly passed in week and encountering sunday it would populate the time object with a priority date of that next sunday BUT an upcoming date of today (Next Sunday - 7 days). It would return the dates, and in this case, once again, it would lead to the creation of another task instance. This will once again re-call the date evaluation funciton. It will again pass in the new prior priority date so as both the start day and the prior priority date. Using that it will now start on the next sunday, ignore it using the prior priority date, continue through the remainder of the week, find no valid days, call itself passing in the next week to evaluate and find the next sunday after that. It would establish the priority and upcoming dates and finding that neither priority nor upcoming dates are before or on todays date it would complete and wait for the day where the priority / upcoming dates to be after the current day to start the cycle again. 

Now I'm wondering whether a task that doesn't have any time details should have a time element associated w/ it? I'm talking exclusively about standard tasks, not event or long terms. Though... long terms would be a task that might have a time (at least w/ the current design) and so having a distinction between a task where time is set vs a task where no time was ever created might make sense... Managing a task that doesn't have time details, however is somewhat more teedious. Bascially when you bring a task up for edit you'll need to determine whether the task has time details or not. Then if it doesn't you'll need to go through one subset of logic and if it does you'll need to go through a different subset of logic. The idea that there's a time element for a starndard task w/o time makes sense because really when you don't put a time you're just saying "today". If you were to edit the task to set it to a different day it would make sense that you'd want to be editing todays date to soemthing else.

Sessions are giving me problems. They're associated w/ times so closely that they're basically times w/ a boolean isSession. The issue is that there's a name associated w/ a session which is where the session table comes into existance. Really this could be changed to have the boolean and add a flngTaskDetailID (maybe change the name of this too) to hold the name details. Where it's a bit more ocmplex is that time is an attribute associated w/ instances... no it's not. An instance has it's time details avaialble to it. A session will never use the time object. 

So I'm wondering about what to store on the task and times for sessions and oneoffs.
So a session is a time w/ a session boolean. When that boolean is set there's a taskdetailid storred on the time that contains the name of the session.
A one off task associated with a sudo-copy'd time using the next priority date as the from and to. The task current stores the time ID associated w/ the copied time. 
When i generate the instance I want that the instance holds a detail that's useful for grouping it into a session and I want that a task asociated w/ a session and a task associated w/ a one off both store the same detail so that they are displayed under the same session header. If I have the instances holding a time ID then I need to join to the time ID and then to the task detail just for the name of a session. So i just changed it to hold the detail id of the time. However now for one offs, when i request to generate the instance I need to get a copy of the time and then get a copy of it's task detail id... again somewhat dumb. Both ways are somewhat teedius and dumb. So lets stick w/ the updated version for now.

So right now I have time instances which have a priority date on them. But when I generate teh task instances I need both a priority from and a priority to in the cases where fblnThru is set and only a priority from in teh cases where fblnThru is false. One question that will help w/ this thought is whether the determine list for instance function needs to have as much details passed to it as it currently does. Right now we have it passing in the from and to but also booleans indicating whether the from and to have times or not and whethere there's a to date provided and the created date. I'm currently having issues w/ some of my tasks because the value being passed into the instance from the time is the the to date associated w/ teh reoccurring time which was created how ever far back. It's not very good. So the first thing that needs to be done is make sure that when we create the instances we're passing in appropriate values. 

So if the instances had appropriate dates (from and to populated with -1, valid date times or valid date & times) do we need the booleans? If we were to simply always assume date time combos we could create a calendar for date time and a calendar for beginning and end of day. We can evaluate the date times and if they happen to match for priority then we're good. My one thought was what if it managed to match for exact times but shouldn't. For example, a task instance that went from saturday thru sunday. the from time would be saturday and the to time would be sunday. Even if there was no time we'd wind up prioritizing it, at the very least on saturday because saturday morning to sunday morning would be an exact match. The only way we would know not to prioritize it is if we had a boolean indicating that there was no time details associated to this. Thinking about this a bit more, this is important specifically for the thru dates as if it wasn't thru we'd simply generate two copies of the from date and apply the to time to it and in that case it's not spanning days so there would be no full days where

So what I want to do is update the system to include fblnThru and the to date for non repetitive tasks as well as allow the year repetition to make use of it as well. I believe fblnto for non repeting tasks works as if fblnThru was checked. I want that this is enabled from the start w/ the option to turn it off if the user wants a new task every day between and including the from and the to dates. When repetition is selected we should pull a system value that determines whether to set or disable fblnThru and they can adjust it accordingly after that. I'd say we set it automatically to true and automatically change it to false for now when they select a repetition. How will this work w/ the time element? If you set fbln thru it becomes from date / time to date / time. If you uncheck fblnThru it becomes every day between and including from and to between the times of from time and to time. To make this work properly the main change necesary is chaning the time instance generation logic to use fblnThru during the non repetition generation logic.

To do this properly I need to worry about what the dates are even more than before. So I've added buttons to remove the times and dates put in. But does that even make sense? I've never had an issue before ... 

Shifting gears. I'm working on fixing the to button w/o the thru button. What I need to do is make it so that the to button is used properly. I will assume bln thru for from and calculate the distance between the from date and the to date to establish the thru value. This is a short term fix that should work for the time being.

Push Notifications - Now that I've made a push notification work I want to incorporate it into my program. My plan is that I want to have 2 push notifications. The first will be an indication that some tasks are waiting to be done today. This will fire in the morning if there are tasks that populate into the today queue. The second (set) of push notifications is for tasks w/ times that fall into the priority queue. The notification will inform the user that new priority tasks are waiting to be completed.

So for this, in general, I want to create an alarm that fires at... 3 am... this alarm will fire a broadcast intent to be picked up by code in my app that will generate any new task instances necessary. I will then evaluate the list of active task instances. If any are due today I will create a notification for day tasks. Then for each task of today w/ a time I will schedule an alarm to go off at each of those times. The alarm will broadcast an intent to be picked up another class that will generate a notification specific to that tasks now being a priority. I believe I can make a single class for the receival of alarms w/ extras to indicate what set of code the class should run. In that class I will also generate the notification function. This is good for a start :)

The first question though is how we can schedule the initial alarm but not schedule multiple alarm calls every time the program is opened. So i think i have a solution. We can configure the program to do an initial alarm during the boot action. This can do the job of scheduling the initial 3:00am generation. However, any instances which had alarms created for them orignally will be lost during a restart. This means that if a phone is restarted during the day that any instances which haven't yet ooccurred will not generate a notification. I would need to do something during this boot process so that I can re-schedule all of the alerts that haven't fired yet. In theory I can set a variable somewhere... When the boot runs it will always do the necessary work of setting up the next 3am alarm. It will also use the time of the day to determine whether it needs to re-generate alerts for priority notifications. If the time is between 12am and before 3am, it doesn't need to ... one more thing to think about... Basically if the phone is on every day than beteen those hours the only task of this boot up intent will be to set up the 3am alarm for the next instance of 3am (might be today, might be tomorrow). However, if the phone has been off for for more than a day (and time is not between those two times) then the intent needs to do everything. To me this screams adding a date to the database to indicate when the last full run of this occurred. So during boot, it will check when the last time a full "sync" occurred if it was today then we don't need to sync again. However if it was yesterday then the boot will be responsible for syncing everything up. If that happens to occur between 12 and 3 then the alarm should be set for the next day, not today. 

Phone restart at 4am (any time after 3 am)
- NO NEED to establish task list for today - But we can do it anyway w/o harm
- NO NEED to generate push for today <--- This winds up being the only difference. 
- Need to set up tomorrow 3am alert
- Need to re generate alerts for priority
- Need to set database sync date

Phone restarts at 2am (any time before 3 am)
- Need to establish task list for today
- Need to generate push for today
- Need to set up tomorrow 3am alert (not today)
- Need to re generate alerts for priority
- Need to set database sync date

Long term completion help
What is this? The idea is that long term goals are hard and so if the task helped you push forward towards completion you'd be better off. So what I was thnking was when you complete a long term task, it should take you to the long term goal list and suggest you add or set up your next task for completion. The issue is this is not that important of a feature... It'd be nice but honestly it'd be annoying to implement and possibly annoying to work with. I'm going to put this on hold.

I'm working on a tool that I can use to display the repetition. Basically this tool needs to populate a live data object with the position # it needs to set a spinner to. So on load this tool needs to take the saved repetititon and nees to know that in a certain case the value being loaded is not the position but is some function different. It then needs to populate the live data object so that an observer can call a function to set the value of the live data as the position of the specific spinner. When that position is set (ON LOAD) we need to call some function in the view model that knows not to try and set the position to something else

I'm working w/ threads now (asynctask which is 1 main and 1 background). I've implemented it for the timekeeper object but am now on the session object and realize that I'm doing some odd loading. The timekeeper viewModel need not wait for the creation of the timekeeper fragment before starting to load and set up details. In theory I could call a function that would start loading the time... skipping for now...

In an ideal world, the instance queue would actually be the record queue. It represents the records that will SOMEHOW display on the main viewer. So right now I have an instance table. All items that populate the task viewer are added here. They are good if I was to simply display a list of all active instances w/o any context as to what those instances represented. However I would like to have a section and subsection detail (in some cases) that can be used to group up the records into more logical pairings. So the question is, how to do that in a way that's easy to understand and reduces coupling. 

I've decided that a section should be stored in a mapping as well. The idea being you pass in an id and a type and that can be used to establish the section id. Issue is, priority, today, standard, upcoming don't have id's. So as such they've got no obvious way to pass in the required detail. Second, when you click the element, there's no way to know what class to call w/o having the viewer directly have a where statement that calls a specific class. The list is going to contain a set of objects. These objects can have a common base class or interface and thus can trigger their own classes version of what ever function needs called. So the whole point of this is so that when you click on an event section it will allow you to complete the entire event. Same w/ a session, but only the contents in the section it's associated w/. So do I need the type variable? really the type is simply a way of obtaining a unique section and subsection key for an element. That key will then be the main way I find and remove all associated instances.

So in the end, i'm going to need a data structure that I can easily return a sublist of elements to... The issue w/ this is that my brain thinks faster than I type... Basically I realize that for an event, I don't need any of this logic. The most I'd need is the ability to know to call an event instance based function so that it can use the event id associated w/ the instance to close all associated instances. So, for each instance, use the instance type to generate a specific type of instance, todo instance, event instance, etc and add it to the array adapter list in the appropriatly. IN the case of event instances there's no need for the hash maps. The hash maps are really most useful in the case of todo instances as the grouping of the todo is not easily re-creatable. 

Get list of active instances
For each, establish type and use class factory to generate appropriate type
call specific class function to populate instance w/ details including title, grouping, subgrouping, type and id and generate any additional records necessary
pass populated list back...

When record is clicked fire method specific to class. Class will...

It almost seems like there's a desire for a new level of abstraction. An instance, is a type of record that displays on the task list but that's not the only things. Really task records are the true notation of what displays on the task list and 1 to many (3 max now) are generated per instance class. Each task record should contain the logic necessary to handle itself so you might have different versions of task records including, a session record, an event record, and event instance record and a todo record.

But we also have the notion that an event should know to create its necessary set of task records and a todo should know to create his set of sections, sessions, and todo records. 

So we'd really be generating two class factories. One generate instance type classes and the other to generate record type classes. The main intent is to simply the logic found in the task viewer.  

So regardless of whether we have 1 instance table or multiple instance tables the main goal is to have specific instance objects provide the details they need for display 

So now I'm to the point where I'm implementing things. I'm realizing that I really want to make sure I create the objects w/ the details they should have for the generation of their appropriate display structures. For todos this includes the session details as well as the instance details. For events this simply includes the instance details and the event details.

So now that I've gone and done this I'm realizing that a lot of functionality that is specific to timed instances was housed in the list viewer application. This somewhat makes sense though as the idea for the app is that displaying items in a list format is ideal for making progress. So basically the entire point of the app will be finding things and turning them into list formatted steps. Regardless it does raise the question of where the heck will I now trigger the logic that updates the timed based visibility of this app? Originally I just updated when ever I looked at the viewer but now that somewhat doesn't make sense as the idea is that anything could be displayed here in the list... BUT, i just realized that a main component of the app is the idea of prioritization of tasks. So really, EVENTS are a weird exception to the design of this concept as they somewhat out prioritize everything as in the moment, it's the highest priority element. 

So maybe I've been a little quick to re-design the app the way I've done. Basically the timed / priority system is THE system. Honestly the real update that I should make is making events able to be scheduled. Thus they will have a time associated w/ them. Then clicking the event will activate it. You should also be able to manually activate the event the normal way except instead of appending it to the priority list it should simply take you to a screen similar to the long terms where you can just go down the list and complete elements until you either complete all elements or you auto complete it. It then should take you back to the main screen where the event will no longer be there. The advantage to this is task priority is maintained. There is no such thing as things higher than priority. In addition, you'll be able to schedule groups of events.

Here's a question. If you have a group of events and also another task that should go on earlier or later, is that a different concept? IN theory there's no time associated w/ events. There's only times associated with event instances. But this is like saying there's no time associated w/ a task, only the instances. This is not true. But the idea stands that you might want to create a GROUP of tasks and events. This group might have repeating times associated w/ it or it might be something you want to fire as one off elements. If it's a one off instance of this group you'd obvously need someway to indicate when the event should start. In addtion, you'll want to associated times to the individual elements of the group.

So really we're talking about a list of subtasks. The list can be scheduled or fired for right now. The sub tasks then use the details associated w/ it to populte into the main list. The details associated w/ the elements, need to strictly be time details though... That's interesting. 

So basically an event could be set to repeat. Same for a task. But if you are to create a group then dates can only be associated to the group and elements associated w/ the group can only have times... BUT THATS LAME. That means that that everything needs to occur in a day but if the group wants to be for a week of things than you're out of luck. It should be that you're allowed to group anything that has a repetition less than the repetition of the group. So if you have a repetition of years you can have ... okay this is getting a bit out of hand. 

Right now I'm really just saying that events are non standard things

Sooo I'm back sort of to squrae 1. I grab a list of all the task instances that exist. Each instance has a type but for now lets assume they're just regular todo tasks. So the first thing that needs to be done is to establish what list items need to be generated for every single instance. This might be up to three items including the queue, the sub queue, and the task... Actually as we're all now in agreement that the priority list is the system I think it's important to auto generate the priority queue list items. So the most a task will be associate w/ will be an additional session. This logic exists in the todo_instance class which implements the instance interface... this is pretty dumb now. Either way each instance would call getDisplayRecords and it would return a list of TaskListRecords necessary to display that item properly. To do this it passes in a hashmap of the items that already exist so that it can know what is necessary to convert. I pass in 2 hash maps right now which no longer needs to be the case...? The main goal is to make sure that a session is unique to its queue. Also I want an entire queue to be completable as well so 

So The system will generate task instances. This is the elements that will display on the instance displayer (main view). I will grab every instance and for each instance create a list item for it as well as any additional grouping elements that might need to be created for it. It will also establish where in the priority queues the item needs to be displayed in. 