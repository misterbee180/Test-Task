When a task instance is generated it's associated w/ the original task and the original task is associated w/ it's time element. The time element in this case exists as a means to know when to generate the task instance entirely. Once the instance is created there's no means for knowning when an instance is actually supposed to be used. This issue is specific to repeating tasks. For non repeating tasks the time detail for the task is the correct time detail for the instance.

Options
1. Each repeating task instance is associated w/ its own time instance.
2. Each repeating task instance is associated w/ a to and from date (the date being the day of the week or month that the task was generated for)

Advanages for 1
1) all time details available and shouldn't be a problem establishing proper queue
2) will have to parse time details all over again

New option:
3. Have a generic time instance w/ only from and to per repeating instance. This will be generated off of the time instance. When editing a task later we can simply edit the tasks instances details

Disadvantage of 1 & 3
1) We're creating a seperation of a task and it's task instance. The user will now need to be aware that when editing a task instance (of a repeating task) that it'll only update the specific instance. This issue is possible less detrimental if we go w/ the generic time record because it won't be repeating and can be made to not allow for repetition selection. This way it'll be apparent that the changes being made to the task instance are specific to the instance. If they wanted to change the task they can go to the task viewer or we can later add a jump to associated task instance 

Implementation of 3
When a task instance is generated it will determine if it's repeating or not. If not it'll assign the time id associated w/ the task to the task instance. If it is repeating then it'll create a new time instance and establish it's dates as non repeating elements. 

We need to add a time ID field to task instance.

Where do we add task instances?
Long term after a task is completed so that we have a record of that tasks completion. This is sketchy but necessary because long term tasks are storred as tasks and don't have any means of signifying completion outside of generating a completed task instance. They also create a task instance when a long term item has a date associated w/ it.

Event tasks create instances when activated. Again, event tasks are created as events and the only way to establish that an event is active is when there's a non completed event task instance. Also to identify which tasks were uncompleted that logic is also used.

The main purpose of having these things create task instances is so that they'd display on the task display screen. At least that's what the main purpose should be. To determine the type of task instance we're working with we look at the associated task and that has the id's of the task type it is.

What date do we need to pass to the time detail associated w/ the task instance. Currently I have it passing out from and to but really, the from date is really all that matters right? The from date will determine if it should fall into T, U, or S queues and the time detail will determine if it falls into T or P. But what if all that's provided is a to date? Well if that's the case (which I don't think you can do now) then the task will never wind up in the U queue. So we would generate an instance and say that the date is today and the time is from until to time. This will be regerated w/ a new from date every day until the to date is met. At which point it will continue to regenerate instances w/ a from date as the to date and will thus always occur in the S section.

With all this said and done I think I'm realizing that a task instance should really incapsulate it's own time details. It does not need to make use of the time table. A task instance should really only need a from date, to date, associated task id

So... w/ all of this said the plan from here on is:
- Update task instance table to include columns:
	- From Date
	- To Date
	- From Time Set
	- To Time Set
	...
	
How will altering a repeating task work w/ new task instances being generated daily? The idea is that a task instance can be regenerated daily but now that we're planning on seperating the editing of a task instance from the editing of a task it becomes a lot more complex. Effectively if you edit a task instance it's in 2 parts. One you want to edit a task's name or description 2) you want to edit a task instances time details 3) you want to edit the tasks time details. So effectively we can't be regenerating task instances daily & allowing the editing of tasks seperately from task instances. Best case scenario you'll wind up with 2 task instances (originating from the same task) but one having been edited from the original task and the other matching the original task. Effectively an editing of a task instance should affect the task but that can't be the case in this new system.

What I want to happen is when I edit a task instance that it knows not to regenerate a new task instance UNTIL the current task instance is completed. But what if I were to edit a task instance and never complete it. Then the entire system design is halted becaus the task is never completed. If a task is a repeating task and the original task instance is altered I'd want it to generate a new instance of task instance when the next repetition opportunity occurred. I don't know if i'd want it to remove the altered version of the task yet. In theory the altered version of the task shouldn't be necessary once a new version of the task is regenerated but what if there were some details specific to that task instance... Currently this is not possible but it might be desired that task instances have base details from their task but can be updated to have differing details later. If this was the case I'd like to keep the altered version of task instance and just generate a new version of the task instance at that time. So what about setting an evaluation date on a task. When the current date is after the evaluation date then we regenerate the task instance. Otherwise we don't regenerate it. This would be good because instead of having a really complex logic for determining what tasks to select for evaluation we simply select all tasks w/ an evaluation date in the past. But what does an evaluation date mean? For a task w/o repetition, I'd imagine there'd be no evaluation date or maybe highdate. This would also be the case for event tasks and long term tasks. For repeting tasks the evaluation date is more critical. If it's repeating on a day schedule the next evaluation would be the next day. If it's repeating on a weekly schedule the next evaluation would be the next day of the week it's associated w/. For month it'd be the next day of the month it's associated w/ and for year it's the next day of year it's associated w/. This brings up 3 questions: 1) What happens if the app doesn't evaluate on a specific evaluation day? 2) If we provide the evaluation day then do we need to do any additional logic on the evaluation day or can we just create the task instance? 3) How will evaluation dates work w/ upcoming task instances?

#3 seems most important to answer first. The evaluation date was originally the day the task instance should be generated BUT if you're expecting task instances to generate a few days out then would the evaluation date change to reflect that? If an evaluation date 

...

Does an event need to be associated w/ a time?
Initially no. An event has tasks associated to it but those tasks are never created for a specific date or time or repetition. An event is simply activated and when activated Task instances are created which allow for view on the main display tool. In this case there is no need for a from and to date as all instances of this type are simply displayed in the event queue. If we were to use task instances as a means for displaying event tasks during activation than we'd need a to identify those instances as associated to an event. This is currently done by linking instances to their task and then to their event. So the answer is no.

So this means that a time detail is not always associated w/ a task and thus a time element should hold a task id and not the other way around. When will a task not have a time detail:
- When no time details are specified during task creation
- When event tasks are created
- When long term tasks are created w/o time details.
Time details will be created when:
- time details are provided during normal task creation
- time details are provided during long term task creation.

In theory a task is either associated w/ no time some sort of time detail. Currently I have it set up that a a time detail contains from and to and extra repetition details exist that make use of thsoe details. Really though you could say that no repetition is a repetition type "None". Then you have the various repetition types (Day, Week, Month, Year). It would almost make sense to just store from and to dates on the actual date type table. The one reservation i have is with the occurrences as this is effectively a detail only specific to repetitions and "None" would never have an occurrence detail. The way it is now, if a time detail exists then it'll have a upcoming and priority date. However if I were to make this change then a task would always be associated to some repetition type, and a none type would have to have an indicator for no time. What I like about this design is that it gets away with repetition types all using the same from and to dates and trying to make that logic work. It does but it's ugly. What I don't like is that a task will always be associated to a repetition type and that in one repetition type (None) I need to handle generation two different ways. We could have repetition type be empty in the case where there's no time details, populated w/ n when there's time but no repetition, and populated w/ other chars when there is repetition. Then when there's no repetition I can know to create a task instance, when there's a repetition i know to use the dates to generate task instance.

Wow I lost a lot of notes that's too bad :( Computer restarts are killer :(

Anyway, now that I have the idea of thru dates I'm wondering about the logic for when you add a task to a session already in progress (for instance, a weekend session, during that weekeend you add an instance). Especially if it's simply a one off. On one hand, the session is still active and so there's teh possibility that you'd want to add it there. On the other hand if you wanted to do the task today you should just add the task to the list today. But what if it's saturday and you want to do it sometime this weekend. So you'd want it this weekend. The logic could be somewhat complex. Add it this weekend and if not completed... no this wouldn't work because if not completed the task instance would never go away. So at this point the only way I can see to do it is to have a checkbox that occurs in this situation that allows generation during current instance. If not checked it'll just assign it to the next logical time instance.

 

Establishing dates for tasks will be done by:
- Establishing create date
- Using occurs in combination w/ the repetition type to determine the repetition instance that occurs directly after or includes the current day.
For day we'd say the task was created on 3/5 and it occurs every day so the date would be set to 4/1 (today)
For week that occurs every 2 weeks and created on 3/5,
- First, we'd determine what the sunday of that week was (beginning of week) 
- Then from that date we'd add multiples of 7 days * 2 (occures) until the current day is either before the new date OR the current day is between the new date and the end of the week of that new date (new date + 7)
- Then establishing what day of the week the current day is we'd find the applicable current or day of the week. 
- If one exists then return that, otherwise call itself w/ the next possible week group.

I think i'm going to change over to only one evaluation dates assocaited w/ a time element. There's no need for 2. However, now I need to consider how that date is actually established w/ respects to upcoming dates being part of the mix. For instance, if the day of the week that a task is set for is wednesdat and there's a 2 day upcoming notice then really the day of the week that I want to find is Monday. Even better, if the day was sunday then the actual date I'm looking for is friday the week before. To accomplish this, I need to establish what that date would be. I would find the week..

I'm struggling w/ establishing the date evaluation logic. There are a few scenarios that are overlapping so I'm going to write them out.

First is the standard case. I create a task that has a repetition date every week for a week day of sunday which happens to be today. In this case I want a task generated for this week. If I were to have my week upcoming settings tuned to 7 days, i'd also want a task instance created for upcoming tasks. I do not want a standard task created for the past. So to make this happen I would get the current week, and evaluate through the days of the week. The first instance should be sunday as that is the beginning of the week. I'd confirm the current day is part of the repetition time and establish the priority date. I would then establish the upcoming date which would be the sunday date - 7 days (in this example). I'd apply both dates to the time object and pass out the generate date from the fucntion. This would lead to the creation of a task instance w/ the priority date as the from date. Then because a task instance was created the date evaluation would occur again. This time I would have a prior priority date. I would use the prior priority date as a beginning cutoff for any future task creation. Thus when it establishes the week to iterate through it will ignore sunday as that day matches the prior priorty date. It would then continue through the week. Though the days would be after the current date they would not match the repetition conditition of sunday and thus would not establish a new date. Once at the end of the week the function would call itself passing the prior priority date and and the new week to evaluate. To do this it would determine what the occur value is and from the beginning of the week jump 7(days) * Occur to move to the beginning of the next week. Once in the new function it would iterate through the newly passed in week and encountering sunday it would populate the time object with a priority date of that next sunday BUT an upcoming date of today (Next Sunday - 7 days). It would return the dates, and in this case, once again, it would lead to the creation of another task instance. This will once again re-call the date evaluation funciton. It will again pass in the new prior priority date so as both the start day and the prior priority date. Using that it will now start on the next sunday, ignore it using the prior priority date, continue through the remainder of the week, find no valid days, call itself passing in the next week to evaluate and find the next sunday after that. It would establish the priority and upcoming dates and finding that neither priority nor upcoming dates are before or on todays date it would complete and wait for the day where the priority / upcoming dates to be after the current day to start the cycle again. 

Now I'm wondering whether a task that doesn't have any time details should have a time element associated w/ it? I'm talking exclusively about standard tasks, not event or long terms. Though... long terms would be a task that might have a time (at least w/ the current design) and so having a distinction between a task where time is set vs a task where no time was ever created might make sense... Managing a task that doesn't have time details, however is somewhat more teedious. Bascially when you bring a task up for edit you'll need to determine whether the task has time details or not. Then if it doesn't you'll need to go through one subset of logic and if it does you'll need to go through a different subset of logic. The idea that there's a time element for a starndard task w/o time makes sense because really when you don't put a time you're just saying "today". If you were to edit the task to set it to a different day it would make sense that you'd want to be editing todays date to soemthing else.

Sessions are giving me problems. They're associated w/ times so closely that they're basically times w/ a boolean isSession. The issue is that there's a name associated w/ a session which is where the session table comes into existance. Really this could be changed to have the boolean and add a flngTaskDetailID (maybe change the name of this too) to hold the name details. Where it's a bit more ocmplex is that time is an attribute associated w/ instances... no it's not. An instance has it's time details avaialble to it. A session will never use the time object. 

So I'm wondering about what to store on the task and times for sessions and oneoffs.
So a session is a time w/ a session boolean. When that boolean is set there's a taskdetailid storred on the time that contains the name of the session.
A one off task associated with a sudo-copy'd time using the next priority date as the from and to. The task current stores the time ID associated w/ the copied time. 
When i generate the instance I want that the instance holds a detail that's useful for grouping it into a session and I want that a task asociated w/ a session and a task associated w/ a one off both store the same detail so that they are displayed under the same session header. If I have the instances holding a time ID then I need to join to the time ID and then to the task detail just for the name of a session. So i just changed it to hold the detail id of the time. However now for one offs, when i request to generate the instance I need to get a copy of the time and then get a copy of it's task detail id... again somewhat dumb. Both ways are somewhat teedius and dumb. So lets stick w/ the updated version for now.

So right now I have time instances which have a priority date on them. But when I generate teh task instances I need both a priority from and a priority to in the cases where fblnThru is set and only a priority from in teh cases where fblnThru is false. One question that will help w/ this thought is whether the determine list for instance function needs to have as much details passed to it as it currently does. Right now we have it passing in the from and to but also booleans indicating whether the from and to have times or not and whethere there's a to date provided and the created date. I'm currently having issues w/ some of my tasks because the value being passed into the instance from the time is the the to date associated w/ teh reoccurring time which was created how ever far back. It's not very good. So the first thing that needs to be done is make sure that when we create the instances we're passing in appropriate values. 

So if the instances had appropriate dates (from and to populated with -1, valid date times or valid date & times) do we need the booleans? If we were to simply always assume date time combos we could create a calendar for date time and a calendar for beginning and end of day. We can evaluate the date times and if they happen to match for priority then we're good. My one thought was what if it managed to match for exact times but shouldn't. For example, a task instance that went from saturday thru sunday. the from time would be saturday and the to time would be sunday. Even if there was no time we'd wind up prioritizing it, at the very least on saturday because saturday morning to sunday morning would be an exact match. The only way we would know not to prioritize it is if we had a boolean indicating that there was no time details associated to this. Thinking about this a bit more, this is important specifically for the thru dates as if it wasn't thru we'd simply generate two copies of the from date and apply the to time to it and in that case it's not spanning days so there would be no full days where  